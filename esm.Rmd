# Modelos Loglineales

## Introducción
La parte teórica de este documento se basa en notas del curso: https://newonlinecourses.science.psu.edu/stat504/node/49/. El objetivo es proporcionar los fundamentos de los modelos estadísticos loglineales y, después, mostrar una aplicación para estimar el tamaño de una población de difícil alcance como lo es la de las víctimas de trata de personas. Esta técnica se conoce como Estimación por Sistemas Múltiples (Multiple System Estimation, en inglés). Los ejemplos incluidos están implementados en el lenguaje R y se incluye el código para replicarlos.

## Modelos Loglineales para dos variables
Los modelos loglineales para dos variables describen las asociaciones y los patrones de interacción entre dos variables aleatorias categóricas. Sea $\mu_{ij}$ el conteo esperado, $E(n_{ij})$ en una tabla $I\times J$ de dos variables aleatorias $A$ y $B$. 

\textbf{Objetivo:} Modelar los conteos por celdas $\mu_{ij}=n\pi_{ij}$.

\textbf{Estructura del modelo:} El modelo loglineal saturado para dos variables con interacción es
$$\log(\mu_{ij})=\mu+\alpha_i+\beta_j+\gamma_{ij}$$
o en notación introducida por Agresti:
$$\log(\mu_{ij})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^{AB}_{ij}$$
donde $i=1,...,I, j=1,...,J$, son niveles de las variables aleatorias categóricas $A$ y $B$, con restricciones
$$\sum_i\lambda_i=\sum_j\lambda_j=\sum_i\sum_j\lambda_{ij}=0$$ para controlar la sobreparametrización. Esto último significa que el número de parámetros es mayor a los que se pueden estimar de manera única. 

### Supuestos del modelo
Las $N=I\times J$ conteos en las celdas son observaciones independientes de una variable aleatoria Poisson $n_{ij}\sim Poisson(\mu_{ij})$.

### Modelos Loglineales para dos variables
Dadas dos variables aleatorias categóricas $A$ y $B$, existen dos tipos de modelos que consideraremos:
  
* Modelo de independencia $(A,B)$
* Modelo saturado $(AB)$
  
## Modelo de Independencia para tablas de dos vías
Recordemos que la independencia se puede enunciar en términos de las probabilidades de las celdas como un producto de probabilidades marginales, $$\pi_{ij}=\pi_{i+}\pi_{+j} \quad i=1,...,I,j=1,...,J$$ 
  y en términos de las frecuencias de las celdas, $$\mu_{ij}=n\pi_{ij}=n\pi_{i+}\pi_{+j} \quad i=1,...,I,j=1,...,J$$.

Al aplicar logaritmo natural en ambos lados de la igualdad, obtenemos el **modelo loglineal de independencia**:
\begin{align*}
\log(\mu_{ij}) & = \log(n)+\log(\pi_{i+})+\log(\pi_{+j}) \\
\log(\mu_{ij}) & = \lambda+\lambda^A_i+\lambda^B_j
\end{align*}
donde los superíndices $A$ y $B$ solamente denotan las dos variables categóricas (Agresti). Este modelo implica que todas las razones de momios deben ser 1.

Ahora, ajustemos el modelo loglineal de independencia de dos vías al ejemplo de los esquiadores. Para ello, usaremos la función `glm()` convirtiendo nuestra tabla en un dataframe.
```{r}
ski.data<-ski.data<-data.frame("Treatment"=c("Placebo","Placebo","VitaminC","VitaminC"),
                               "Cold"=c("Cold","NoCold","Cold","NoCold"),
                               "Freq"=c(31,109,17,122))
ski.data
```
Al aplicar `glm()` se requiere especificar `ski.data$Freq` como la variable que contiene los conteos de las celdas. En este modelo tenemos dos efectos principales sin el término de interacción. Es decir, `ski.data$Treatment+ski.data$Cold`. Finalmente, debemos especificar la distribución, en el caso de los modelos loglineales se debe definir `family=poisson()`. 
```{r}
ski.ind<-glm(ski.data$Freq~ski.data$Treatment+ski.data$Cold, family=poisson())

#### to view the model and the relevant statistics

ski.ind
```

Otra forma de ver el modelo:
```{r}
summary(ski.ind)
```

## Modelo Saturado para tablas de dos vías
En este caso, también ajustaremos el término *interacción*, es decir, la asociación entre $A$ y $B$.

### Estructura del modelo 
$$\log(\mu_{ij})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^{AB}_{ij}$$
Aquí, $\lambda_{ij}^{AB}$ representa la interacción/asociación entre dos variables.

Ahora, añadimos un término de interacción al modelo `ski.data$Treatment*ski.data$Cold`:
```{r}
ski.sat<-glm(ski.data$Freq~ski.data$Treatment*ski.data$Cold, family=poisson())
ski.sat
anova(ski.sat)
```

## Modelos Loglineales para tres variables

Para tablas de tres vías, existen múltiples modelos que se pueden probar y, luego, ajustar. Los modelos loglineales son:
  
| Tipo    | Modelo Loglineal | Notación | 
|:--------| :-----------------------------------------------------------------| :--------: |
| I. mutua| $\log(\mu_{ijk})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^C_k$     | $(A,B,C)$  |
| I. conjunta | $\log(\mu_{ijk})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^C_k+\lambda^{AB}_{ij}$| $(AB,C)$  |
| I. condicional | $\log(\mu_{ijk})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^C_k+\lambda^{AB}_{ij}+\lambda^{BC}_{jk}$| $(AB,BC)$  |
| Asociación Homogénea | $\log(\mu_{ijk})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^C_k+\lambda^{AB}_{ij}+\lambda^{BC}_{jk}+\lambda^{AC}_{ik}$| $(AB,BC,AC)$  |
| Saturado | $\log(\mu_{ijk})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^C_k+\lambda^{AB}_{ij}+\lambda^{BC}_{jk}+\lambda^{AC}_{ik}+\lambda^{ABC}_{ijk}$|$(ABC)$|
  
### Modelo Loglineal Saturado
Este modelo es el modelo por omisión que sirve para pruebas de bondad de ajuste de los otros modelos. Recordemos que el modelo saturado tiene el máximo número de parámetros y ajustar un modelo saturado es lo mismo que estimar parámetros de máxima verosimilitud de distribuciones apropiadas para cada celda de la tabla de contingencia.

### Estructura del modelo
$$\log(\mu_{ijk})=\lambda+\lambda^A_i+\lambda^B_j+\lambda^C_k+\lambda^{AB}_{ij}+\lambda^{AC}_{ik}+\lambda^{BC}_{jk}+\lambda^{ABC}_{ijk}$$
Las restricciones implican 
$$\sum_i\lambda_i^A=\sum_j\lambda_j^B=\sum_i\sum_j\lambda_{ij}^{AB}=\sum_i\sum_j\sum_k\lambda_{ijk}^{ABC}=0$$
El modelo saturado tiene un ajuste perfecto, $G^2=0$, $g.l.=0$ con $g.l.=$ número de celdas - el número de parámetros únicos en el modelo. El modelo saturado es el modelo más complejo posible. La selección del modelo es relevante al comparar con modelos más simples.

### Ejemplo. Consumo de alcohol, cigarro y marihuana
La siguiente tabla muestra los resultados de un encuesta donde se le preguntó a estudiantes del último año de una preparatoria en Ohio si alguna vez habían consumido alcohol, cigarro o marihuana.

| Alcohol   | Cigarro      | Marihuana (Si)| Marihuana (No)|
| :--------:| :----------: | -----------:  | -----------: |
| Si        | Si           | 911           | 538          |
|           | No           | 44            | 456          |
| No        | Si           | 3             | 43           |
|           | No           | 2             | 279          |
  
```{r}
freq<-c(911,3,44,2,538,43,456,279)
nombres<-list(A=c("Si","No"),C=c("Si","No"),M=c("Si","No"))
drogas.tab<-array(freq,c(2,2,2),dimnames = nombres)
drogas.tab
```

En este ejemplo, usaremos el paquete `MASS` y la función `step` para encontrar el modelo más parsimonioso, es decir, aquel que ajuste los datos lo mejor posible con el menor número de parámetros. 
```{r}
library("MASS")
sat<-loglm(~ A*C*M, data=drogas.tab)
stp<-step(sat, direction = "backward",test="Chisq")
stp
```
Enseguida, podemos ver el resumen del procedimiento
```{r}
summary(stp)
```
\newpage
# Estimación por Sistemas Múltiples
En esta sección se ilustran los pasos para realizar una estimación del tamaño de una población a partir de listados de víctimas incompletos. El conjunto de datos utilizado representa una población de 10000 individuos. Estas notas han sido originalmente elaboradas por [Maarten Cruyff](https://www.uu.nl/staff/mcruyff), consultor de UNODC.

## Planteamiento
Comenzamos cargando los datos del archivo `data.csv`.
```{r}
d<-read.csv("data.csv")
head(d)
```
Supóngase que se ha hecho la identificación de coincidencias de tres listas incompletas de víctimas de trata $A,B,C$ donde `0` significa que no fue identificada o registrada y `1` que sí se identificó. Las variables `X1,X2` contienen características de la población, *covariados*, por ejemplo, `X1` es el sexo donde `1` es hombre y `2` es mujer y `X2` es la edad donde `1` es menor de edad y `2` es adulto. Las frecuencias en los renglones con ceros para $A,B$ y $C$ tienen `NA` porque son las celdas que corresponden a la víctimas que no se registraron en alguna de las tres listas. Estos son los valores que se desean estimar.

## Estimación con dos sistemas
Primero, consideraremos el caso en el que se tienen dos listas $A,B$ sin covariados. 
```{r}
AB <- subset(d, select = c(A, B, Freq), subset = A==1 | B==1)
d_AB <- as.data.frame(xtabs(Freq ~ A + B, data = AB))
d_AB
```
La frecuencia de la celda $n_{00}$ es cero pues se trata de las víctimas que no fueron registradas en alguna de las dos listas. A las celdas con esta característica las llamaremos *ceros estructurales*. Ahora, formulamos el modelo para estimar su valor.

El modelo loglineal saturado $(AB)$ para dos listas $A$ y $B$ es
$$\log m_{ij}=\lambda_0+\lambda^A_i+\lambda^B_j+\lambda^{AB}_{ij},$$
para $i,j\in\{0,1\}$, donde $m_{ij}$ es la frecuencia ajustada de la celda $ij$. Recordemos que la notación $(AB)$ representa el modelo jerárquico que contiene el efecto de interacción, así como los efectos principales de $A$ y $B$. 

Desafortunadamente, este modelo está sobreparametrizado porque tiene 4 parámetros y sólo 3 frecuencias observadas. Para resolver esto, hacemos que el parámetro de interacción sea cero. Es decir, usaremos el modelo $(A,B)$:
$$\log m_{ij}=\lambda_0+\lambda^A_i+\lambda^B_j,$$
el cual supone que la probabilidad de inclusión en una lista es independiente de la probabilidad de inclusión de otra lista. Ajustamos el modelo con la función `glm()` al conjunto de datos `d_AB` sin el cero estructural:
```{r}
d_AB.glm <- glm(Freq ~ A + B, family = poisson, data = d_AB, 
                subset = !(A == 0 & B == 0))
```
Veamos el resumen de la estimación:
```{r}
summary(d_AB.glm)
```
Para estimar la frecuencia de la celda $m_{00}$, utilizamos la siguiente instrucción:
```{r}
d_AB.pred <- predict(d_AB.glm, newdata = d_AB, type = "response")
```
La suma de estas frecuencias nos da el tamaño de la población estimada
```{r}
Nhat_AB <- sum(d_AB.pred)
```
### Ejercicio. Ejecute el mismo análisis para las parejas $A,C$ y $B,C$.

## Estimación con dos sistemas y covariados
La inclusión de los covariados en el modelo permitirá que la inclusión de probabilidades varíe sobre los niveles de estos. Nuevamente, sólo consideraremos las listas $A$ y $B$ añadiendo la información de $X_1$ y $X_2$:
```{r}
ABX   <- subset(d, select = c(A, B, X1, X2, Freq), subset = !(A == 0 & B == 0))
d_ABX <- as.data.frame(xtabs(Freq ~ A + B + X1 + X2, data = ABX))
d_ABX
```
En este conjunto de datos hay 4 ceros estructurales, uno para cada combinación de los covariados. Entonces el modelo ahora es $(AX_1X_2, BX_1X_2)$, o bien:
$$\log m_{ijkl}=\lambda_0+\lambda^A_i+\lambda^B_j+\lambda^{X_1}_k+\lambda^{X_2}_l+\lambda^{AX_1}_{ik}+\lambda^{AX_2}_{il}+\lambda^{BX_1}_{ik}+\lambda^{BX_2}_{il}+\lambda^{X_1X_2}_{kl}+\lambda^{AX_1X_2}_{ikl}+\lambda^{BX_1X_2}_{jkl}.$$
Para encontrar el modelo más parsimonioso, usaremos la función `step()`. Esta función requiere que se ajuste el modelo de los efectos principales:
```{r}
d_ABX.main <- glm(Freq ~ ., family=poisson, data = d_ABX, subset = !(A==0 & B==0))
```
Enseguida, aplicamos el procedimiento *stepwise* al modelo anterior. Para ello, necesitamos especificar el alcance de los modelos en los cuales buscar el más parsimonioso. Esto es, $(AX_1X_2, BX_1X_2)$
```{r}
d_ABX.step <- step(d_ABX.main, scope = ~ (A + B)*X1*X2)
d_ABX.step
```
El tamaño de la población estimada es:
```{r}
d_ABX.pred <- predict(d_ABX.step, newdata = d_ABX, type = "response")
Nhat_ABX <- sum(d_ABX.pred)
```
También, podemos obtener los valores estimados para los niveles de los covariados:
```{r}
xtabs(d_ABX.pred ~ X1, data=d_ABX)
```
## Estimación con tres sistemas y covariados
A continuación, añadiremos una tercera lista al modelo. Recordemos que la principal ventaja es que esto permitirá interacciones por parejas de listas. Por lo tanto, utilizaremos toda la información del conjunto `d` replicando los mismos pasos del ejercicio anterior.
```{r}
xtabs(Freq ~ A + B + C, data=d)
```
Ajustemos el modelo de efectos principales `Freq~A+B+C+X1+X2` al conjunto `d` excluyendo los ceros estructurales con el comando `subset`. Guarde el objeto como `d.main`.
```{r echo=FALSE}
d.main <- glm(Freq ~ ., family = poisson, data = d, 
              subset = !(A == 0 & B == 0 & C == 0))
```
Ahora, estimemos el modelo más parsimonioso para `d` usando la función `step()` y estableciendo como alcance el modelo de asociaciones homégeneas en combinación con los covariados. Guarde el modelo como `d.step`.
```{r echo=FALSE}
d.step <- step(d.main, scope = ~ (A*B + A*C + B*C)*X1*X2)
```
Enseguida, guardamos los valores de la predicción como `d.pred` y el tamaño de la población como `Nhat`.
```{r echo=FALSE}
d.pred <- predict(d.step, newdata = d, type = "response")
Nhat <- sum(d.pred)
Nhat
```
## Intervalo de confianza
Por último, calcularemos un intervalo de confianza alrededor de $\hat{N}$ con el método bootstrap el cual simulará una muestra aleatoria de una distribución multinomial. Luego, se filtrarán los ceros estructurales de los datos y se ajustará el modelo para obtener las predicciones del conjunto completo, así como el tamaño de la población. Repetiremos este proceso 1000 veces y se calculará los percentiles 2.5 y 97.5.
```{r cache=TRUE}
set.seed(10)
boot.nhats <- NULL
for(i in 1:1000){
  d.sample   <- sample(1:32, size=Nhat, replace=TRUE, prob=d.pred/Nhat)
  d.boot     <- as.data.frame(table(d[d.sample, -6]))
  boot.glm   <- glm(d.step$formula, family=poisson, data=d.boot, 
                    subset=!(A==0&B==0&C==0))
  boot.pred  <- predict(boot.glm, newdata=d.boot, type="response")
  boot.nhats <- c(boot.nhats, sum(boot.pred))
}
quantile(boot.nhats, c(.025, .975))
```
